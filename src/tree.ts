import { TableModel, TextModel } from './toad'

export enum TableEventType {
    // Model Messages (generated by model)
    INSERT_ROW, REMOVED_ROW,
    INSERT_COL, REMOVED_COL,
    CONTENT, // content was modified, but no row/cols added/removed

    // TableAdapter messages (not generated by models)
    RESIZED_ROW, RESIZED_COL,
    CHANGED, // new model
}

export class TableEvent {
    type: TableEventType
    index: number
    size: number
    constructor(type: TableEventType, index: number, size: number) {
        this.type = type
        this.index = index
        this.size = size
    }
}

export abstract class TreeModel<T> extends TableModel {

    constructor() {
        super()
        this.rows = new Array<TreeModel.Row<T>>()
    }

    get colCount(): number { return 1 }
    get rowCount(): number { return 1 }

    addSiblingBefore(row: number): number {
        const nn = this.createNode()
        if (this.rows.length === 0) {
            row = 0
            this.setRoot(nn)
            this.rows.push(new TreeModel.Row(nn, 0))
        } else {
            if (row === 0) {
                this.setNext(nn, this.getRoot())
                this.setRoot(nn)
                this.rows.unshift(new TreeModel.Row(nn, 0))
            } else {
                this.setNext(nn, this.rows[row].node)
                if (this.getNext(this.rows[row-1].node) === this.rows[row].node)
                    this.setNext(this.rows[row-1].node, nn)
                else
                    this.setDown(this.rows[row-1].node, nn)
                this.rows.splice(row, 0, new TreeModel.Row(nn, 0))
            }            
        }
        this.modified.trigger(new TableEvent(TableEventType.INSERT_ROW, row, 1))
        return row
    }

    addSiblingAfter(row: number): number {
        const nn = this.createNode()
        if (this.rows.length === 0) {
            row = 0
            this.setRoot(nn)
            this.rows.push(new TreeModel.Row(nn, 0))
        } else {
            this.setNext(nn, this.getNext(this.rows[row].node))
            this.setNext(this.rows[row].node, nn)

            const count = this.nodeCount(this.getDown(this.rows[row].node))
            // console.log(`addSiblingAfter: subtree has ${count} nodes`)
            row += count + 1
            this.rows.splice(row, 0, new TreeModel.Row(nn, 0))
        }
        this.modified.trigger(new TableEvent(TableEventType.INSERT_ROW, row, 1))
        return row
    }

    addChildAfter(row: number): number {
        const nn = this.createNode()
        if (this.rows.length === 0) {
            this.setRoot(nn)
            this.rows.push(new TreeModel.Row(nn, 0))
            this.modified.trigger(new TableEvent(TableEventType.INSERT_ROW, 0, 1))
        } else {
            this.setDown(nn, this.getDown(this.rows[row].node))
            this.setDown(this.rows[row].node, nn)
            this.rows.splice(row+1, 0, new TreeModel.Row(nn, 0))
            this.modified.trigger(new TableEvent(TableEventType.INSERT_ROW, row + 1, 1))
        }
        return row
    }

    addParentBefore(row: number): number {
        const nn = this.createNode()
        if (row === 0) {
            this.setDown(nn, this.getRoot())
            this.setRoot(nn)
            this.rows.unshift(new TreeModel.Row(nn, 0))
        } else {
            this.setDown(nn, this.rows[row].node)
            this.setNext(nn, this.getNext(this.rows[row].node))
            this.setNext(this.rows[row].node, undefined)
            if (this.getNext(this.rows[row-1].node) === this.rows[row].node)
                this.setNext(this.rows[row-1].node, nn)
            else
                this.setDown(this.rows[row-1].node, nn)
            this.rows.splice(row, 0, new TreeModel.Row(nn, 0))
        }
        this.modified.trigger(new TableEvent(TableEventType.INSERT_ROW, row, 1))
        return row
    }
    
    deleteAt(row: number): number {
        let down = this.getDown(this.rows[row].node)
        if (down !== undefined) {
            // move child to current position
            this.append(down, this.getNext(this.rows[row].node))
            this.setNext(this.rows[row].node, undefined)
            if (row === 0) {
                this.setRoot(down)
            } else {
                this.setNext(this.rows[row-1].node, down)
            }
        } else {
            // move sibling to current position
            if (row === 0) {
                const next = this.getNext(this.rows[row].node)
                this.setNext(this.rows[row].node, undefined)
                this.setRoot(next)
            } else {
                const next = this.getNext(this.rows[row].node)
                this.setNext(this.rows[row].node, undefined)

                // this.setDown(this.rows[row-1].node, next)
                if (this.getNext(this.rows[row-1].node) === this.rows[row].node)
                    this.setNext(this.rows[row-1].node, next)
                else
                    this.setDown(this.rows[row-1].node, next)
            }
        }
        this.rows.splice(row, 1)
        this.modified.trigger(new TableEvent(TableEventType.REMOVED_ROW, row, 1))
        return row
    }

    private append(chain: T, node?: T) {
        if (node === undefined)
            return
        let p = chain
        let next
        while(true) {
            next = this.getNext(p)
            if (next === undefined)
                break
            p = next 
        }
        this.setNext(p, node)
    }

    private nodeCount(node?: T): number {
        if (node === undefined)
            return 0
        return 1 + this.nodeCount(this.getDown(node)) + this.nodeCount(this.getNext(node))
    }

    rows: Array<TreeModel.Row<T>>

    abstract createNode(): T
    abstract deleteNode(node: T): void
    abstract getRoot(): T | undefined
    abstract setRoot(node?: T): void
    abstract getDown(node: T): T | undefined
    abstract setDown(node: T, down?: T): void
    abstract getNext(node: T): T | undefined
    abstract setNext(node: T, next?: T): void
}

export namespace TreeModel {
    export class Row<T> {
        node: T
        depth: number
        constructor(node: T, depth: number) {
            this.node = node
            this.depth = depth
        }
    }
}

export interface TreeNode {
    next?: TreeNode
    down?: TreeNode
}

export abstract class TreeNodeModel<T extends TreeNode> extends TreeModel<T> {
    nodeClass: new() => T
    root?: T
    constructor(nodeClass: new() => T, root?: T) {
        super()
        this.nodeClass = nodeClass
        this.root = root
    }
    
    createNode(): T { return new this.nodeClass() }
    deleteNode(node: T): void {}
    getRoot(): T | undefined { return this.root }
    setRoot(node?: T): void { this.root = node }
    getDown(node: T): T | undefined { return node.down as T }
    setDown(node: T, down?: T): void { node.down = down }
    getNext(node: T): T | undefined { return node.next as T }
    setNext(node: T, next?: T): void { node.next = next }
}
