/*
 *  The TOAD JavaScript/TypeScript GUI Library
 *  Copyright (C) 2021 Mark-Andr√© Hopf <mhopf@mark13.org>
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import { TextModel, View, Model, bind } from '../toad'
import { TypedTableModel } from "./TypedTableModel"
import { text, line, rectangle } from "../svg"

export enum TableEventType {
    // Model Messages (generated by model)
    INSERT_ROW, REMOVED_ROW,
    INSERT_COL, REMOVED_COL,
    CONTENT, // content was modified, but no row/cols added/removed

    // TableAdapter messages (not generated by models)
    RESIZED_ROW, RESIZED_COL,
    CHANGED, // new model
}

// TODO: rename into TableModelEvent ???
export class TableEvent {
    type: TableEventType
    index: number
    size: number
    constructor(type: TableEventType, index: number, size: number) {
        this.type = type
        this.index = index
        this.size = size
    }
}

export abstract class TreeModel<T> extends TypedTableModel<T> {

    constructor(nodeClass: new() => T) {
        super(nodeClass)
        this.rows = new Array<TreeModel.Row<T>>()
    }

    get colCount(): number { return 1 }
    get rowCount(): number { return this.rows.length }

    addSiblingBefore(row: number): number {
        const nn = this.createNode()
        if (this.rows.length === 0) { // TODO: can we remove this?
            row = 0
            this.setRoot(nn)
            this.rows.push(new TreeModel.Row(nn, 0))
        } else {
            if (row === 0) {
                this.setNext(nn, this.getRoot())
                this.setRoot(nn)
                this.rows.unshift(new TreeModel.Row(nn, 0))
            } else {
                this.setNext(nn, this.rows[row].node)
                if (this.getNext(this.rows[row-1].node) === this.rows[row].node)
                    this.setNext(this.rows[row-1].node, nn)
                else
                    this.setDown(this.rows[row-1].node, nn)
                this.rows.splice(row, 0, new TreeModel.Row(nn, this.rows[row].depth))
            }            
        }
        this.modified.trigger(new TableEvent(TableEventType.INSERT_ROW, row, 1))
        return row
    }

    addSiblingAfter(row: number): number {
        const nn = this.createNode()
        if (this.rows.length === 0) {
            row = 0
            this.setRoot(nn)
            this.rows.push(new TreeModel.Row(nn, 0))
        } else {
            this.setNext(nn, this.getNext(this.rows[row].node))
            this.setNext(this.rows[row].node, nn)

            const count = this.nodeCount(this.getDown(this.rows[row].node))
            // console.log(`addSiblingAfter: subtree has ${count} nodes`)
            const depth = this.rows[row].depth
            row += count + 1
            this.rows.splice(row, 0, new TreeModel.Row(nn, depth))
        }
        this.modified.trigger(new TableEvent(TableEventType.INSERT_ROW, row, 1))
        return row
    }

    addChildAfter(row: number): number {
        const nn = this.createNode()
        if (this.rows.length === 0) {
            this.setRoot(nn)
            this.rows.push(new TreeModel.Row(nn, 0))
            this.modified.trigger(new TableEvent(TableEventType.INSERT_ROW, 0, 1))
        } else {
            const down = this.getDown(this.rows[row].node)

            const subtreeSize = this.nodeCount(down)
            // console.log(`subtreeSize = ${subtreeSize}`)
            for(let i=0; i<subtreeSize; ++i)
                 ++this.rows[row+1+i].depth

            this.setDown(nn, down)
            this.setDown(this.rows[row].node, nn)

            this.rows.splice(row+1, 0, new TreeModel.Row(nn, this.rows[row].depth + 1))
            this.modified.trigger(new TableEvent(TableEventType.INSERT_ROW, row + 1, 1))
        }
        return row
    }

    addParentBefore(row: number): number {
        const nn = this.createNode()
        if (row === 0) {
            for(let i=0; i<this.rows.length; ++i)
                 ++this.rows[row+i].depth
            this.setDown(nn, this.getRoot())
            this.setRoot(nn)
            this.rows.unshift(new TreeModel.Row(nn, 0))
        } else {
            const depth = this.rows[row].depth
            const subtreeSize = this.nodeCount(this.getDown(this.rows[row].node)) + 1
            // console.log(`row = ${row}, this.rows.length=${this.rows.length}, subtreeSize = ${subtreeSize}`)
            for(let i=0; i<subtreeSize; ++i)
                 ++this.rows[row+i].depth

            this.setDown(nn, this.rows[row].node)
            this.setNext(nn, this.getNext(this.rows[row].node))

            this.setNext(this.rows[row].node, undefined)
            if (this.getNext(this.rows[row-1].node) === this.rows[row].node)
                this.setNext(this.rows[row-1].node, nn)
            else
                this.setDown(this.rows[row-1].node, nn)
            this.rows.splice(row, 0, new TreeModel.Row(nn, depth))
        }
        this.modified.trigger(new TableEvent(TableEventType.INSERT_ROW, row, 1))
        return row
    }
    
    deleteAt(row: number): number {
        let down = this.getDown(this.rows[row].node)
        if (down !== undefined) {
            // move child to current position

            const subtreeSize = this.nodeCount(down) + 1
            // console.log(`row = ${row}, this.rows.length=${this.rows.length}, subtreeSize = ${subtreeSize}`)
            for(let i=0; i<subtreeSize; ++i)
                 --this.rows[row+i].depth

            this.append(down, this.getNext(this.rows[row].node))
            this.setNext(this.rows[row].node, undefined)
            if (row === 0) {
                this.setRoot(down)
            } else {
                this.setNext(this.rows[row-1].node, down)
            }
        } else {
            // move sibling to current position
            if (row === 0) {
                const next = this.getNext(this.rows[row].node)
                this.setNext(this.rows[row].node, undefined)
                this.setRoot(next)
            } else {
                const next = this.getNext(this.rows[row].node)
                this.setNext(this.rows[row].node, undefined)

                // this.setDown(this.rows[row-1].node, next)
                if (this.getNext(this.rows[row-1].node) === this.rows[row].node)
                    this.setNext(this.rows[row-1].node, next)
                else
                    this.setDown(this.rows[row-1].node, next)
            }
        }
        this.rows.splice(row, 1)
        this.modified.trigger(new TableEvent(TableEventType.REMOVED_ROW, row, 1))
        return row
    }

    private append(chain: T, node?: T) {
        if (node === undefined)
            return
        let p = chain
        let next
        while(true) {
            next = this.getNext(p)
            if (next === undefined)
                break
            p = next 
        }
        this.setNext(p, node)
    }

    private nodeCount(node?: T): number {
        if (node === undefined)
            return 0
        return 1 + this.nodeCount(this.getDown(node)) + this.nodeCount(this.getNext(node))
    }

    rows: Array<TreeModel.Row<T>>

    abstract createNode(): T
    abstract deleteNode(node: T): void
    abstract getRoot(): T | undefined
    abstract setRoot(node?: T): void
    abstract getDown(node: T): T | undefined
    abstract setDown(node: T, down?: T): void
    abstract getNext(node: T): T | undefined
    abstract setNext(node: T, next?: T): void
}

export namespace TreeModel {
    export class Row<T> {
        node: T
        open: boolean
        depth: number
        constructor(node: T, depth: number) {
            this.node = node
            this.depth = depth
            this.open = true
        }
    }
}

export interface TreeNode {
    next?: TreeNode
    down?: TreeNode
}

export abstract class TreeNodeModel<T extends TreeNode> extends TreeModel<T> {
    root?: T
    constructor(nodeClass: new() => T, root?: T) {
        super(nodeClass)
        this.nodeClass = nodeClass
        this.root = root
    }
    
    createNode(): T { return new this.nodeClass() }
    deleteNode(node: T): void {}
    getRoot(): T | undefined { return this.root }
    setRoot(node?: T): void { this.root = node }
    getDown(node: T): T | undefined { return node.down as T }
    setDown(node: T, down?: T): void { node.down = down }
    getNext(node: T): T | undefined { return node.next as T }
    setNext(node: T, next?: T): void { node.next = next }
}

class Node {
    label: string
    next?: Node
    down?: Node

    static counter = 0

    constructor(label?: string, next?: Node, down?: Node) {
        if (label === undefined)
            this.label = `#${Node.counter++}`
        else
            this.label = label
        this.next = next
        this.down = down
    }
    print(indent = 0) {
        console.log(`${"  ".repeat(indent)} ${this.label}`)
        if (this.down)
            this.down.print(indent+1)
        if (this.next)
            this.next.print(indent)
    }
}

const sx = 12     // horizontal step width
const dx = 3.5    // additional step before drawing the rectangle
const dy = 4.5    // step from top to rectangle
const rs = 8      // rectangle width and height
const rx = 3      // horizontal line from rectangle to data on the left
const item_h = 20 // height of row

class TreeNodeView extends View {
    model: TreeModel<Node>
    row: TreeModel.Row<Node>

    constructor(model: TreeModel<Node>, row: TreeModel.Row<Node>) {
        super()
        this.model = model
        this.row = row
        this.attachShadow({mode: 'open'})
        // this.shadowRoot!.appendChild(document.importNode(this.getStyle(), true))
        this.shadowRoot!.appendChild(this.create())
        // this.input = document.createElement("input") 
        // this.input.oninput = () => { this.updateModel() }
        // this.attachShadow({mode: 'open'})
        // this.shadowRoot!.appendChild(document.importNode(textStyle, true))
        // this.shadowRoot!.appendChild(this.input)
    }

    create(): Element {

        // console.log("-------------------- TreeNodeView.create() -------------------------")

        let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg")
        svg.style.border = "none"
        svg.style.display = "block"
        svg.setAttributeNS("", "width", "70")
        svg.setAttributeNS("", "height", `${item_h}`)

        const d = this.row.depth

        svg.appendChild(text(d*sx+dx+sx+5, dy+8, this.row.node.label))

        if (this.row.node.down) {
            // box
            svg.appendChild(rectangle(d*sx+dx, dy, rs, rs))
            // minus
            svg.appendChild(line(d*sx+dx+(rs>>2), dy+(rs>>1), d*sx+dx+rs-(rs>>2), dy+(rs>>1)))
            if (!this.row.open) {
                // plus
                svg.appendChild(line(d*sx+dx+(rs>>1), dy+(rs>>2), d*sx+dx+(rs>>1), dy+rs-(rs>>2)))
            }
            // horizontal line to data
            svg.appendChild(line(d*sx+dx+rs, dy+(rs>>1), d*sx+dx+rs+rx, dy+(rs>>1)))
        } else {
            // upper vertical line instead of box
            svg.appendChild(line(d*sx+dx+(rs>>1), dy, d*sx+dx+(rs>>1), dy+(rs>>1)))
            // horizontal line to data
            svg.appendChild(line(d*sx+dx+(rs>>1), dy+(rs>>1), d*sx+dx+rs+rx, dy+(rs>>1)))
        }

        // small line above box
        svg.appendChild(line(d*sx+dx+(rs>>1),0, d*sx+dx+(rs>>1), dy))

        // lines connecting nodes
        let row
        for(row = 0; this.model.rows[row] !== this.row; ++row) {}

        // console.log(`render tree graphic for row ${row} at depth ${d}`)

        for(let i=0; i<=d; ++i) {
            // console.log(`check row ${row}, depth ${i}`)
            for(let j=row+1; j<this.model.rowCount; ++j) {
                if (this.model.rows[j].depth < i)
                    break
                if ( i === this.model.rows[j].depth) {
                    if ( i!== d) {
                        // long line without box
                        svg.appendChild(line(i*sx+dx+(rs>>1),0,i*sx+dx+(rs>>1), item_h))
                    } else {
                        // small line below box
                        if (row+1 < this.model.rows.length && this.model.rows[row+1].depth > this.row.depth) {
                            // has subtree => start below box
                            svg.appendChild(line(i*sx+dx+(rs>>1),dy+rs,i*sx+dx+(rs>>1),item_h))
                        } else {
                            // has no subtree => has no box => don't start below box
                            svg.appendChild(line(i*sx+dx+(rs>>1),dy+(rs>>1),i*sx+dx+(rs>>1),item_h))
                        }
                    }
                    break
                }
            }
        }
        return svg
    }

    setModel(model?: Model): void {
    }
}
window.customElements.define("toad-treenode", TreeNodeView)

class NoModel extends Model {
}

class MyTreeModel extends TreeNodeModel<Node> {
    getFieldModel(col: number, row: number): TextModel {
        if (col < 0 || col >= this.colCount || row < 0 || row >= this.rowCount)
            throw Error(`MyTreeModel.getFieldModel(${col}, ${row}) is out of range`)
        return new NoModel() as TextModel
    }

    getFieldView(col: number, row: number): View {
        // console.log(`MyTreeModel.getFieldView(${col}, ${row})`)
        return new TreeNodeView(this, this.rows[row])
    }
}

export function myTreeTest() {
    let tree = new MyTreeModel(Node)
    tree.addSiblingAfter(0)
    tree.addChildAfter(0)
    tree.addChildAfter(1)
    tree.addSiblingAfter(1)
    tree.addSiblingAfter(0)
    bind("books", tree)
}